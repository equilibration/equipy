

<!DOCTYPE html>


<html lang="en" data-content_root="" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>equipy.fairness._wasserstein &#8212; EquiPy 0.0.3 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=5b4479735964841361fd" rel="stylesheet" />
<link href="../../../_static/styles/bootstrap.css?digest=5b4479735964841361fd" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=5b4479735964841361fd" rel="stylesheet" />

  
  <link href="../../../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=5b4479735964841361fd" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" href="../../../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=5b4479735964841361fd" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=5b4479735964841361fd" />
  <script src="../../../_static/vendor/fontawesome/6.1.2/js/all.min.js?digest=5b4479735964841361fd"></script>

    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/equipy/fairness/_wasserstein';</script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>

  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  

<a class="navbar-brand logo" href="../../../index.html">
  
  
  
  
  
  
    <p class="title logo__title">EquiPy 0.0.3 documentation</p>
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../modules.html">equipy</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-1"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../equipy.html">equipy package</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-2"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../equipy.fairness.html">equipy.fairness package</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../equipy.graphs.html">equipy.graphs package</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../equipy.metrics.html">equipy.metrics package</a></li>
</ul>
</li>
</ul>
</li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">



<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>

</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1></h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <h1>Source code for equipy.fairness._wasserstein</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Main Classes to make predictions fair.</span>

<span class="sd">The module structure is as follows:</span>

<span class="sd">- The FairWasserstein base Class implements fairness adjustment related to a single sensitive attribute, using Wasserstein distance for both binary classification and regression tasks. In the case of binary classification, this class supports scores instead of classes. For more details, see E. Chzhen, C. Denis, M. Hebiri, L. Oneto and M. Pontil, &quot;Fair Regression with Wasserstein Barycenters&quot; (NeurIPS20).</span>
<span class="sd">- MultiWasserstein Class extends FairWasserstein for multi-sensitive attribute fairness adjustment in a sequential framework. For more details, see F. Hu, P. Ratz, A. Charpentier, &quot;A Sequentially Fair Mechanism for Multiple Sensitive Attributes&quot; (AAAI24).</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># Authors: Agathe F, Suzie G, Francois H, Philipp R, Arthur C</span>
<span class="c1"># License: BSD 3 clause</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">from</span> <span class="nn">..utils.checkers</span> <span class="kn">import</span> <span class="n">_check_epsilon</span><span class="p">,</span> <span class="n">_check_epsilon_size</span><span class="p">,</span> <span class="n">_check_mod</span><span class="p">,</span> <span class="n">_check_shape</span><span class="p">,</span> <span class="n">_check_nb_observations</span><span class="p">,</span> <span class="n">_check_col</span><span class="p">,</span> <span class="n">_check_unique_mod</span>
<span class="kn">from</span> <span class="nn">..metrics._fairness_metrics</span> <span class="kn">import</span> <span class="n">identity</span>
<span class="kn">from</span> <span class="nn">._base</span> <span class="kn">import</span> <span class="n">BaseHelper</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>
<span class="kn">import</span> <span class="nn">random</span>


<div class="viewcode-block" id="FairWasserstein"><a class="viewcode-back" href="../../../equipy.fairness.html#equipy.fairness.FairWasserstein">[docs]</a><span class="k">class</span> <span class="nc">FairWasserstein</span><span class="p">(</span><span class="n">BaseHelper</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class implementing Wasserstein distance-based fairness adjustment for binary classification and regression tasks regarding a single sensitive attribute.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sigma : float, optional (default=0.0001)</span>
<span class="sd">        Standard deviation of the random noise added during fairness adjustment.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    sigma : float</span>
<span class="sd">        Standard deviation of the random noise added during fairness adjustment.</span>
<span class="sd">    modalities_calib : dict</span>
<span class="sd">        Dictionary storing modality values obtained from calibration data.</span>
<span class="sd">    weights : dict</span>
<span class="sd">        Dictionary storing weights (probabilities) for each modality based on their occurrences in calibration data.</span>
<span class="sd">    ecdf : dict</span>
<span class="sd">        Dictionary storing ECDF (Empirical Cumulative Distribution Function) objects for each sensitive modality.</span>
<span class="sd">    eqf : dict</span>
<span class="sd">        Dictionary storing EQF (Empirical Quantile Function) objects for each sensitive modality.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0001</span><span class="p">,</span> <span class="n">seed</span> <span class="o">=</span> <span class="mi">2023</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">modalities_calib</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">columns_calib</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

<div class="viewcode-block" id="FairWasserstein.fit"><a class="viewcode-back" href="../../../equipy.fairness.html#equipy.fairness.FairWasserstein.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sensitive_feature</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform fit on the calibration data and save the ECDF, EQF, and weights of the sensitive variable.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y : np.ndarray, shape (n_samples,)</span>
<span class="sd">            The calibration predictions.</span>

<span class="sd">        sensitive_feature : Union[np.ndarray, pd.DataFrame], shape (n_samples, 1)</span>
<span class="sd">            The calibration samples representing one single sensitive attribute.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method computes the ECDF (Empirical Cumulative Distribution Function),</span>
<span class="sd">        EQF (Empirical Quantile Function), and weights for the sensitive variable</span>
<span class="sd">        based on the provided calibration data. These computed values are used</span>
<span class="sd">        during the transformation process to ensure fairness in predictions.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; wasserstein = FairWasserstein(sigma=0.001)</span>
<span class="sd">        &gt;&gt;&gt; y = np.array([0.0, 1.0, 1.0, 0.0])</span>
<span class="sd">        &gt;&gt;&gt; sensitive_feature = pd.DataFrame({&#39;nb_child&#39;: [1, 2, 0, 2]})</span>
<span class="sd">        &gt;&gt;&gt; wasserstein.fit(y, sensitive_feature)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_check_shape</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sensitive_feature</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sensitive_feature</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">sensitive_feature</span> <span class="o">=</span> <span class="n">sensitive_feature</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> 
            <span class="n">sensitive_feature</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                <span class="n">sensitive_feature</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;sens</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sensitive_feature</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
                <span class="p">)</span>
        <span class="n">_check_unique_mod</span><span class="p">(</span><span class="n">sensitive_feature</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">modalities_calib</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_modalities</span><span class="p">(</span><span class="n">sensitive_feature</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">columns_calib</span> <span class="o">=</span> <span class="n">sensitive_feature</span><span class="o">.</span><span class="n">columns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_weights</span><span class="p">(</span><span class="n">sensitive_feature</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_estimate_ecdf_eqf</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sensitive_feature</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">)</span></div>

<div class="viewcode-block" id="FairWasserstein.transform"><a class="viewcode-back" href="../../../equipy.fairness.html#equipy.fairness.FairWasserstein.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sensitive_feature</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">],</span> <span class="n">epsilon</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform the test data to enforce fairness using Wasserstein distance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y : np.ndarray, shape (n_samples,)</span>
<span class="sd">            The predictions of the test data.</span>

<span class="sd">        sensitive_feature : Union[np.ndarray, pd.DataFrame], shape (n_samples, 1)</span>
<span class="sd">            The test samples representing a single sensitive attribute.</span>

<span class="sd">        epsilon : float, optional (default=0)</span>
<span class="sd">            The fairness parameter controlling the trade-off between fairness and accuracy.</span>
<span class="sd">            It represents the fraction of the original predictions retained after fairness adjustment.</span>
<span class="sd">            Epsilon should be a value between 0 and 1, where 0 means full fairness and 1 means no fairness constraint.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        y_fair : np.ndarray, shape (n_samples,)</span>
<span class="sd">            Fair predictions for the test data after enforcing fairness constraints.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method applies Wasserstein distance-based fairness adjustment to the test data</span>
<span class="sd">        using the precomputed ECDF (Empirical Cumulative Distribution Function),</span>
<span class="sd">        EQF (Empirical Quantile Function), and weights obtained from the calibration data.</span>
<span class="sd">        Random noise within the range of [-sigma, sigma] is added to the test data to ensure fairness.</span>
<span class="sd">        The parameter epsilon controls the trade-off between fairness and accuracy,</span>
<span class="sd">        with 0 enforcing full fairness and 1 retaining the original predictions.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Evgenii Chzhen, Christophe Denis, Mohamed Hebiri, Luca Oneto and Massimiliano Pontil, &quot;Fair Regression with Wasserstein Barycenters&quot; (NeurIPS20)</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; y = np.array([0.05, 0.08, 0.9, 0.9, 0.01, 0.88])</span>
<span class="sd">        &gt;&gt;&gt; sensitive_feature = pd.DataFrame({&#39;nb_child&#39;: [1, 3, 2, 3, 1, 2]})</span>
<span class="sd">        &gt;&gt;&gt; wasserstein = FairWasserstein(sigma=0.001)</span>
<span class="sd">        &gt;&gt;&gt; wasserstein.fit(y, sensitive_feature)</span>
<span class="sd">        &gt;&gt;&gt; y = np.array([0.01, 0.99, 0.98, 0.04])</span>
<span class="sd">        &gt;&gt;&gt; sensitive_feature = pd.DataFrame({&#39;nb_child&#39;: [3, 1, 2, 3]})</span>
<span class="sd">        &gt;&gt;&gt; print(wasserstein.transform(y, sensitive_feature, epsilon=0.2))</span>
<span class="sd">        [0.26063673 0.69140959 0.68940959 0.26663673]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">_check_epsilon</span><span class="p">(</span><span class="n">epsilon</span><span class="p">)</span>
        <span class="n">_check_shape</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sensitive_feature</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sensitive_feature</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">sensitive_feature</span> <span class="o">=</span> <span class="n">sensitive_feature</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> 
            <span class="n">sensitive_feature</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                <span class="n">sensitive_feature</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;sens</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sensitive_feature</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
                <span class="p">)</span>
        <span class="n">modalities_test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_modalities</span><span class="p">(</span><span class="n">sensitive_feature</span><span class="p">)</span>
        <span class="n">columns_test</span> <span class="o">=</span> <span class="n">sensitive_feature</span><span class="o">.</span><span class="n">columns</span>
        <span class="n">_check_mod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">modalities_calib</span><span class="p">,</span> <span class="n">modalities_test</span><span class="p">)</span>
        <span class="n">_check_col</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns_calib</span><span class="p">,</span> <span class="n">columns_test</span><span class="p">)</span>

        <span class="n">y_fair</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fair_y_values</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sensitive_feature</span><span class="p">,</span> <span class="n">modalities_test</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">epsilon</span><span class="p">)</span><span class="o">*</span><span class="n">y_fair</span> <span class="o">+</span> <span class="n">epsilon</span><span class="o">*</span><span class="n">y</span></div>
    
    <span class="k">def</span> <span class="nf">fit_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y_calib</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sensitive_feature_calib</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">],</span> <span class="n">y_test</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sensitive_feature_test</span><span class="p">:</span><span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">],</span> <span class="n">epsilon</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit and transform the calibration and test data to enforce fairness using Wasserstein distance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y_calib : np.ndarray, shape (n_samples,)</span>
<span class="sd">            The prediction values of the calibration data.</span>

<span class="sd">        sensitive_feature_calib : Union[np.ndarray, pd.DataFrame], shape (n_samples, 1)</span>
<span class="sd">            The calibration samples representing a single sensitive attribute.</span>

<span class="sd">        y_test : np.ndarray, shape (n_samples,)</span>
<span class="sd">            The prediction values of the test data.</span>

<span class="sd">        sensitive_feature_test : Union[np.ndarray, pd.DataFrame], shape (n_samples, 1)</span>
<span class="sd">            The test samples representing a single sensitive attribute.</span>

<span class="sd">        epsilon : float, optional (default=0)</span>
<span class="sd">            The fairness parameter controlling the trade-off between fairness and accuracy.</span>
<span class="sd">            It represents the fraction of the original predictions retained after fairness adjustment.</span>
<span class="sd">            Epsilon should be a value between 0 and 1, where 0 means full fairness and 1 means no fairness constraint.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        y_fair : np.ndarray, shape (n_samples,)</span>
<span class="sd">            Fair predictions for the test data after enforcing fairness constraints.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method applies Wasserstein distance-based fairness adjustment to the test data</span>
<span class="sd">        using the precomputed ECDF (Empirical Cumulative Distribution Function),</span>
<span class="sd">        EQF (Empirical Quantile Function), and weights obtained from the calibration data.</span>
<span class="sd">        Random noise within the range of [-sigma, sigma] is added to the test data to ensure fairness.</span>
<span class="sd">        The parameter epsilon controls the trade-off between fairness and accuracy,</span>
<span class="sd">        with 0 enforcing full fairness and 1 retaining the original predictions.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Evgenii Chzhen, Christophe Denis, Mohamed Hebiri, Luca Oneto and Massimiliano Pontil, &quot;Fair Regression with Wasserstein Barycenters&quot; (NeurIPS20)</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; y_calib = np.array([0.05, 0.08, 0.9, 0.9, 0.01, 0.88])</span>
<span class="sd">        &gt;&gt;&gt; sensitive_feature_calib = pd.DataFrame({&#39;nb_child&#39;: [1, 3, 2, 3, 1, 2]})</span>
<span class="sd">        &gt;&gt;&gt; y_test = np.array([0.01, 0.99, 0.98, 0.04])</span>
<span class="sd">        &gt;&gt;&gt; sensitive_feature_test = pd.DataFrame({&#39;nb_child&#39;: [3, 1, 2, 3]})</span>
<span class="sd">        &gt;&gt;&gt; wasserstein = FairWasserstein(sigma=0.001)</span>
<span class="sd">        &gt;&gt;&gt; print(wasserstein.fit_transform(y_calib, sensitive_feature_calib, y_test, sensitive_feature_test, epsilon=0.2))</span>
<span class="sd">        [0.26063673 0.69140959 0.68940959 0.26663673]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">y_calib</span><span class="p">,</span> <span class="n">sensitive_feature_calib</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">sensitive_feature_test</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">)</span></div>


<div class="viewcode-block" id="MultiWasserstein"><a class="viewcode-back" href="../../../equipy.fairness.html#equipy.fairness.MultiWasserstein">[docs]</a><span class="k">class</span> <span class="nc">MultiWasserstein</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class extending FairWasserstein for multi-sensitive attribute fairness adjustment.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sigma : float, optional (default=0.0001)</span>
<span class="sd">        Standard deviation of the random noise added during fairness adjustment.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    sigma : float</span>
<span class="sd">        Standard deviation of the random noise added during fairness adjustment.</span>
<span class="sd">    y_fair : dict</span>
<span class="sd">        Dictionary storing fair predictions for each sensitive feature.</span>
<span class="sd">    modalities_calib_all : dict</span>
<span class="sd">        Dictionary storing modality values obtained from calibration data for all sensitive features.</span>
<span class="sd">    weights_all : dict</span>
<span class="sd">        Dictionary storing weights (probabilities) for each modality based on their occurrences in calibration data</span>
<span class="sd">        for all sensitive features.</span>
<span class="sd">    ecdf_all : dict</span>
<span class="sd">        Dictionary storing ECDF (Empirical Cumulative Distribution Function) objects for each sensitive modality</span>
<span class="sd">        for all sensitive features.</span>
<span class="sd">    eqf_all : dict</span>
<span class="sd">        Dictionary storing EQF (Empirical Quantile Function) objects for each sensitive modality</span>
<span class="sd">        for all sensitive features.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0001</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the MultiWasserStein instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sigma : float, optional (default=0.0001)</span>
<span class="sd">            The standard deviation of the random noise added to the data during transformation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">y_fair</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">modalities_calib_all</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">columns_calib_all</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">weights_all</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">eqf_all</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ecdf_all</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span>

<div class="viewcode-block" id="MultiWasserstein.fit"><a class="viewcode-back" href="../../../equipy.fairness.html#equipy.fairness.MultiWasserstein.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sensitive_features</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform fit on the calibration data and save the ECDF, EQF, and weights for each sensitive variable.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y : np.ndarray, shape (n_samples,)</span>
<span class="sd">            The calibration predictions.</span>

<span class="sd">        sensitive_features : Union[np.ndarray, pd.DataFrame], shape (n_samples, n_sensitive_features)</span>
<span class="sd">            The calibration samples representing multiple sensitive attributes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method computes the ECDF (Empirical Cumulative Distribution Function),</span>
<span class="sd">        EQF (Empirical Quantile Function), and weights for each sensitive variable</span>
<span class="sd">        based on the provided calibration data. These computed values are used</span>
<span class="sd">        during the transformation process to ensure fairness in predictions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_check_nb_observations</span><span class="p">(</span><span class="n">sensitive_features</span><span class="p">)</span>
        <span class="n">_check_shape</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sensitive_features</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sensitive_features</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sensitive_features</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">sensitive_features</span> <span class="o">=</span> <span class="n">sensitive_features</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">sensitive_features</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                <span class="n">sensitive_features</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;sens</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sensitive_features</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
                <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">columns_calib_all</span> <span class="o">=</span> <span class="n">sensitive_features</span><span class="o">.</span><span class="n">columns</span>

        <span class="n">y_inter</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">sensitive_features</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sensitive_features</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">modalities_calib_all</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">weights_all</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ecdf_all</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">eqf_all</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">sensitive_filtered</span> <span class="o">=</span> <span class="n">sensitive_features</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="n">col</span><span class="p">])</span>
                <span class="n">combinations</span> <span class="o">=</span> <span class="n">sensitive_filtered</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">combinations</span><span class="p">[</span><span class="s1">&#39;concat&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">combinations</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">sensitive_filtered</span> <span class="o">=</span> <span class="n">sensitive_filtered</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">[</span><span class="s1">&#39;concat&#39;</span><span class="p">]:</span>
                    <span class="n">cond</span> <span class="o">=</span> <span class="n">sensitive_filtered</span> <span class="o">==</span> <span class="n">value</span>
                    <span class="n">intersection</span> <span class="o">=</span> <span class="n">sensitive_features</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">wasserstein_instance</span> <span class="o">=</span> <span class="n">FairWasserstein</span><span class="p">(</span><span class="n">sigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">intersection</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">modalities_calib_all</span><span class="p">[</span><span class="n">col</span><span class="p">][</span><span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">intersection</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">weights_all</span><span class="p">[</span><span class="n">col</span><span class="p">][</span><span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">intersection</span><span class="o">.</span><span class="n">unique</span><span class="p">()[</span><span class="mi">0</span><span class="p">]:</span> <span class="mi">1</span><span class="p">}</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">eqf_all</span><span class="p">[</span><span class="n">col</span><span class="p">][</span><span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">intersection</span><span class="o">.</span><span class="n">unique</span><span class="p">()[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">identity</span><span class="p">}</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">ecdf_all</span><span class="p">[</span><span class="n">col</span><span class="p">][</span><span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">intersection</span><span class="o">.</span><span class="n">unique</span><span class="p">()[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">identity</span><span class="p">}</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">new_sens</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;intersection&#39;</span><span class="p">:</span> <span class="n">intersection</span><span class="p">})</span>
                        <span class="n">wasserstein_instance</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">y_inter</span><span class="p">[</span><span class="n">cond</span><span class="p">],</span> <span class="n">new_sens</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">modalities_calib_all</span><span class="p">[</span><span class="n">col</span><span class="p">][</span><span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="n">wasserstein_instance</span><span class="o">.</span><span class="n">modalities_calib</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">weights_all</span><span class="p">[</span><span class="n">col</span><span class="p">][</span><span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="n">wasserstein_instance</span><span class="o">.</span><span class="n">weights</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">eqf_all</span><span class="p">[</span><span class="n">col</span><span class="p">][</span><span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="n">wasserstein_instance</span><span class="o">.</span><span class="n">eqf</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">ecdf_all</span><span class="p">[</span><span class="n">col</span><span class="p">][</span><span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="n">wasserstein_instance</span><span class="o">.</span><span class="n">ecdf</span>
                        <span class="n">y_inter</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="n">wasserstein_instance</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">y_inter</span><span class="p">[</span><span class="n">cond</span><span class="p">],</span> <span class="n">new_sens</span><span class="p">)</span>
                <span class="n">sensitive_features</span> <span class="o">=</span> <span class="n">sensitive_features</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">col</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">wasserstein_instance</span> <span class="o">=</span> <span class="n">FairWasserstein</span><span class="p">(</span><span class="n">sigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">)</span>
                <span class="n">wasserstein_instance</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">y_inter</span><span class="p">,</span> <span class="n">sensitive_features</span><span class="p">[[</span><span class="n">col</span><span class="p">]])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">modalities_calib_all</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">wasserstein_instance</span><span class="o">.</span><span class="n">modalities_calib</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">weights_all</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">wasserstein_instance</span><span class="o">.</span><span class="n">weights</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">eqf_all</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">wasserstein_instance</span><span class="o">.</span><span class="n">eqf</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ecdf_all</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">wasserstein_instance</span><span class="o">.</span><span class="n">ecdf</span>
                <span class="n">y_inter</span> <span class="o">=</span> <span class="n">wasserstein_instance</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">y_inter</span><span class="p">,</span> <span class="n">sensitive_features</span><span class="p">[[</span><span class="n">col</span><span class="p">]])</span></div>
    
<div class="viewcode-block" id="MultiWasserstein.transform"><a class="viewcode-back" href="../../../equipy.fairness.html#equipy.fairness.MultiWasserstein.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sensitive_features</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">],</span> <span class="n">epsilon</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform the calib and test data to enforce fairness using Wasserstein distance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y : np.ndarray, shape (n_samples,)</span>
<span class="sd">            The prediction values of the test data.</span>

<span class="sd">        sensitive_features : Union[np.ndarray, pd.DataFrame] shape (n_samples, n_sensitive_features)</span>
<span class="sd">            The test samples representing multiple sensitive attributes.</span>

<span class="sd">        epsilon : list, shape (n_sensitive_features,), optional (default=None)</span>
<span class="sd">            The fairness parameters controlling the trade-off between fairness and accuracy</span>
<span class="sd">            for each sensitive feature. If None, no fairness constraints are applied.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        y_fair : np.ndarray, shape (n_samples,)</span>
<span class="sd">            Fair predictions for the test data after enforcing fairness constraints.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method applies Wasserstein distance-based fairness adjustment to the test data</span>
<span class="sd">        using the precomputed ECDF (Empirical Cumulative Distribution Function),</span>
<span class="sd">        EQF (Empirical Quantile Function), and weights obtained from the calibration data.</span>
<span class="sd">        Random noise within the range of [-sigma, sigma] is added to the test data to ensure fairness.</span>
<span class="sd">        The parameter epsilon is a list, where each element controls the trade-off between fairness and accuracy</span>
<span class="sd">        for the corresponding sensitive feature.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        François Hu, Philipp Ratz, Arthur Charpentier, &quot;A Sequentially Fair Mechanism for Multiple Sensitive Attributes&quot; (AAAI24)</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; wasserstein = MultiWasserStein(sigma=0.001)</span>
<span class="sd">        &gt;&gt;&gt; y = np.array([0.6, 0.43, 0.32, 0.8])</span>
<span class="sd">        &gt;&gt;&gt; sensitive_features = pd.DataFrame({&#39;color&#39;: [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;, &#39;blue&#39;], &#39;nb_child&#39;: [1, 2, 0, 2]})</span>
<span class="sd">        &gt;&gt;&gt; wasserstein.fit(y, sensitive_features)</span>
<span class="sd">        &gt;&gt;&gt; y = np.array([0.8, 0.35, 0.23, 0.2])</span>
<span class="sd">        &gt;&gt;&gt; sensitive_features = pd.DataFrame({&#39;color&#39;: [&#39;blue&#39;, &#39;blue&#39;, &#39;blue&#39;, &#39;green&#39;], &#39;nb_child&#39;: [2, 2, 1, 2]})</span>
<span class="sd">        &gt;&gt;&gt; epsilon = [0.1, 0.2] </span>
<span class="sd">        &gt;&gt;&gt; fair_predictions = wasserstein.transform(y, sensitive_features, epsilon=epsilon)</span>
<span class="sd">        &gt;&gt;&gt; print(fair_predictions)</span>
<span class="sd">        [0.42483123 0.36412012 0.36172012 0.36112012]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sensitive_features</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sensitive_features</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">sensitive_features</span> <span class="o">=</span> <span class="n">sensitive_features</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> 
            <span class="n">sensitive_features</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                <span class="n">sensitive_features</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;sens</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sensitive_features</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
                <span class="p">)</span>
        <span class="k">if</span> <span class="n">epsilon</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sensitive_features</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">epsilon</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">epsilon</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">sensitive_features</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">_check_epsilon_size</span><span class="p">(</span><span class="n">epsilon</span><span class="p">,</span> <span class="n">sensitive_features</span><span class="p">)</span>
        <span class="n">_check_col</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns_calib_all</span><span class="p">,</span> <span class="n">sensitive_features</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">y_fair</span><span class="p">[</span><span class="s1">&#39;Base model&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>
        <span class="n">y_inter</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sensitive_features</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sensitive_features</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">sens_filtered</span> <span class="o">=</span> <span class="n">sensitive_features</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="n">col</span><span class="p">])</span>
                <span class="n">combinations</span> <span class="o">=</span> <span class="n">sens_filtered</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">combinations</span><span class="p">[</span><span class="s1">&#39;concat&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">combinations</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">sens_filtered</span> <span class="o">=</span> <span class="n">sens_filtered</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">[</span><span class="s1">&#39;concat&#39;</span><span class="p">]:</span>
                    <span class="n">cond</span> <span class="o">=</span> <span class="n">sens_filtered</span> <span class="o">==</span> <span class="n">value</span>
                    <span class="n">intersection</span> <span class="o">=</span> <span class="n">sensitive_features</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">new_sens</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;intersection&#39;</span><span class="p">:</span> <span class="n">intersection</span><span class="p">})</span>
                    <span class="n">wasserstein_instance</span> <span class="o">=</span> <span class="n">FairWasserstein</span><span class="p">(</span><span class="n">sigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">)</span>
                    <span class="n">wasserstein_instance</span><span class="o">.</span><span class="n">columns_calib</span> <span class="o">=</span> <span class="n">new_sens</span><span class="o">.</span><span class="n">columns</span>
                    <span class="n">wasserstein_instance</span><span class="o">.</span><span class="n">modalities_calib</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">modalities_calib_all</span><span class="p">[</span><span class="n">col</span><span class="p">][</span><span class="n">value</span><span class="p">]</span>
                    <span class="n">wasserstein_instance</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights_all</span><span class="p">[</span><span class="n">col</span><span class="p">][</span><span class="n">value</span><span class="p">]</span>
                    <span class="n">wasserstein_instance</span><span class="o">.</span><span class="n">eqf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eqf_all</span><span class="p">[</span><span class="n">col</span><span class="p">][</span><span class="n">value</span><span class="p">]</span>
                    <span class="n">wasserstein_instance</span><span class="o">.</span><span class="n">ecdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ecdf_all</span><span class="p">[</span><span class="n">col</span><span class="p">][</span><span class="n">value</span><span class="p">]</span>
                    <span class="n">y_inter</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="n">wasserstein_instance</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">y_inter</span><span class="p">[</span><span class="n">cond</span><span class="p">],</span> <span class="n">new_sens</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">sensitive_features</span> <span class="o">=</span> <span class="n">sensitive_features</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">col</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">wasserstein_instance</span> <span class="o">=</span> <span class="n">FairWasserstein</span><span class="p">(</span><span class="n">sigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">)</span>
                <span class="n">wasserstein_instance</span><span class="o">.</span><span class="n">columns_calib</span> <span class="o">=</span> <span class="n">sensitive_features</span><span class="p">[[</span><span class="n">col</span><span class="p">]]</span><span class="o">.</span><span class="n">columns</span>
                <span class="n">wasserstein_instance</span><span class="o">.</span><span class="n">modalities_calib</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">modalities_calib_all</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
                <span class="n">wasserstein_instance</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights_all</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
                <span class="n">wasserstein_instance</span><span class="o">.</span><span class="n">eqf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eqf_all</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
                <span class="n">wasserstein_instance</span><span class="o">.</span><span class="n">ecdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ecdf_all</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
                <span class="n">wasserstein_instance</span><span class="o">.</span><span class="n">columns_calib</span> <span class="o">=</span> <span class="n">sensitive_features</span><span class="p">[[</span><span class="n">col</span><span class="p">]]</span><span class="o">.</span><span class="n">columns</span>
                <span class="n">y_inter</span> <span class="o">=</span> <span class="n">wasserstein_instance</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">y_inter</span><span class="p">,</span> <span class="n">sensitive_features</span><span class="p">[[</span><span class="n">col</span><span class="p">]],</span> <span class="n">epsilon</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>                                                                     
            <span class="bp">self</span><span class="o">.</span><span class="n">y_fair</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_inter</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_fair</span><span class="p">[</span><span class="n">col</span><span class="p">]</span></div>
    
    <span class="k">def</span> <span class="nf">fit_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y_calib</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sensitive_features_calib</span><span class="p">:</span><span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">],</span> <span class="n">y_test</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sensitive_features_test</span><span class="p">:</span><span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">],</span><span class="n">epsilon</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit and transform the calibration and test data to enforce fairness using Wasserstein distance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y_calib : np.ndarray, shape (n_samples,)</span>
<span class="sd">            The calibration predictions.</span>

<span class="sd">        sensitive_features_calub : Union[np.ndarray, pd.DataFrame], shape (n_samples, n_sensitive_features)</span>
<span class="sd">            The calibration samples representing multiple sensitive attributes.</span>

<span class="sd">        y_test : np.ndarray, shape (n_samples,)</span>
<span class="sd">            The target values of the test data.</span>

<span class="sd">        sensitive_features_test : Union[np.ndarray, pd.DataFrame] shape (n_samples, n_sensitive_features)</span>
<span class="sd">            The test samples representing multiple sensitive attributes.</span>

<span class="sd">        epsilon : list, shape (n_sensitive_features,), optional (default=None)</span>
<span class="sd">            The fairness parameters controlling the trade-off between fairness and accuracy</span>
<span class="sd">            for each sensitive feature. If None, no fairness constraints are applied.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        y_fair : np.ndarray, shape (n_samples,)</span>
<span class="sd">            Fair predictions for the test data after enforcing fairness constraints.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method applies Wasserstein distance-based fairness adjustment to the test data</span>
<span class="sd">        using the precomputed ECDF (Empirical Cumulative Distribution Function),</span>
<span class="sd">        EQF (Empirical Quantile Function), and weights obtained from the calibration data.</span>
<span class="sd">        Random noise within the range of [-sigma, sigma] is added to the test data to ensure fairness.</span>
<span class="sd">        The parameter epsilon is a list, where each element controls the trade-off between fairness and accuracy</span>
<span class="sd">        for the corresponding sensitive feature.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        François Hu, Philipp Ratz, Arthur Charpentier, &quot;A Sequentially Fair Mechanism for Multiple Sensitive Attributes&quot; (AAAI24)</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; wasserstein = MultiWasserStein(sigma=0.001)</span>
<span class="sd">        &gt;&gt;&gt; y_calib = np.array([0.6, 0.43, 0.32, 0.8])</span>
<span class="sd">        &gt;&gt;&gt; sensitive_features_calib = pd.DataFrame({&#39;color&#39;: [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;, &#39;blue&#39;], &#39;nb_child&#39;: [1, 2, 0, 2]})</span>
<span class="sd">        &gt;&gt;&gt; y_test = [0.8, 0.35, 0.23, 0.2]</span>
<span class="sd">        &gt;&gt;&gt; sensitive_features_test = pd.DataFrame({&#39;color&#39;: [&#39;blue&#39;, &#39;blue&#39;, &#39;blue&#39;, &#39;green&#39;], &#39;nb_child&#39;: [2, 2, 1, 2]})</span>
<span class="sd">        &gt;&gt;&gt; epsilon = [0.1, 0.2] </span>
<span class="sd">        &gt;&gt;&gt; print(wasserstein.fit_transform(y_calib, sensitive_features_calib, y_test, sensitive_features_test, epsilon))</span>
<span class="sd">        [0.42483123 0.36412012 0.36172012 0.36112012]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">y_calib</span><span class="p">,</span> <span class="n">sensitive_features_calib</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">sensitive_features_test</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_sequential_fairness</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dictionary containing fair outputs generated at each iteration of the application of the transform method.</span>
<span class="sd">        These outputs represent the predictions for the test data after enforcing fairness at each step.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        y_sequential_fair : dict</span>
<span class="sd">            A dictionary containing fair predictions for the test data at each iteration of applying the fairness transformations, regarding one sensitive attribute.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">y_sequential_fair</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_fair</span>
        <span class="k">return</span> <span class="n">y_sequential_fair</span></div>
</pre></div>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Agathe F, Suzie G, Francois H, Philipp R, Arthur C
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2023, Agathe F, Suzie G, Francois H, Philipp R, Arthur C.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/bootstrap.js?digest=5b4479735964841361fd"></script>
<script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=5b4479735964841361fd"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>